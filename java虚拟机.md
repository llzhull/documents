









# Java虚拟机                                                                                                                                                                                                                       

参考链接：https://blog.csdn.net/qq_41701956/article/details/81664921

### Java程序的执行过程

![img](https://pic2.zhimg.com/80/v2-622285a8b4b8af51c35fca7651e27841_720w.jpg)

java源文件到最后运行起来，主要会经过以下阶段：

- .java文件通过java编译器（javac.exe）编译成.class文件，这个就是所说的字节码文件。
- .class文件加载到jvm进行运行

## JVM

### JVM是如何处理.class 文件的

先看下JVM的结构

![img](https://pic4.zhimg.com/80/v2-73ccd948b2d98055aa28261a18dd145b_720w.jpg)

JVM被分为三个主要的子系统

（1）类加载器子系统（2）运行时数据区（3）执行引擎

## 类加载器子系统

### 虚拟机类加载机制（ClassLoader）

虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、装换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。

类的加载指的是：

- 将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，
- 然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。
- 类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。
  
  

### 类加载器

**类加载器** 就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。

通过一个类的全限定名来获取描述此类的二进制字节流。

将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内

### 类加载时机

类的生命周期

<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjdhYzg3ZjQzOTJmMGFiOTllNGM2NWMyM2NjNzE5NDU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" style="zoom:50%;" />

以下几种情况必须对类进行初始化

- 1、遇到new 、getStatic、putStatic或invokeStatic 这四条字节码指令时，没初始化触发初始化。

  使用场景使用new 关键字实例化对象时、读取一个类的静态字段、调用一个类的静态方法时。

- 使用 java.lang.reflect 包中的方法对类进行反射调用的时候。

- 当初始化一个类的时候，如果发现其父类还没有进行初始化，则先需要触发其父类的初始化。

- 当虚拟机启动时，用户指定一个需要加载的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。

  

### 类的加载过程

#### 加载

#### 验证

#### 准备

为类的静态变量分配内存，并将其初始化为默认值

#### 解析

把类中的符号引用转换为直接引用

#### 初始化

初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：

- 声明类变量是指定初始值
- 使用静态代码块为类变量指定初始值

### 双亲委派机制

双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

**双亲委派模型图：**

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzIzLzE2YzFjNTRjZjRhZDg4NmI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ?x-oss-process=image/format,png)

**双亲委派机制:**

- 1、当`AppClassLoader`加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器`ExtClassLoader`去完成。
- 2、当`ExtClassLoader`加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给`BootStrapClassLoader`去完成。
- 3、如果`BootStrapClassLoader`加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用`ExtClassLoade`r来尝试加载；
- 4、若`ExtClassLoader`也加载失败，则会使用`AppClassLoader`来加载
- 5、如果`AppClassLoader`也加载失败，则会报出异常ClassNotFoundException。

**双亲委派模型意义：**

- 系统类防止内存中出现多份同样的字节码
- 保证Java程序安全稳定运行

## 运行时数据区

根据《Java 虚拟机规范(Java SE 7 版)》规定，Java虚拟机所管理的内存如下图所示

<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGQzYjE1YjNkODgyNmZhZWFlMjA2Mzk3NmZiOTkyMTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" style="zoom: 50%;" />

### Java虚拟机栈

线程私有，生命周期和线程一致。描述的是Java方法执行的内存模型：

每个方法在执行时，都会先创建一个栈帧（Stack Frame)用于存储**局部变量表、操作数栈、动态链接、方法出口**等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。

存储当前线程运行方法所需的数据，指令、返回地址。

#### 局部变量表

存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、double、long)、对象引用、返回地址类型（指向了一条字节码指令的地址）

StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。

​		栈的深度是固定的，栈中存放着栈帧，但是每个栈帧的大小不一。

OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。

#### 操作数栈

#### 动态链接

#### 方法出口



### 本地方法栈

区别于Java虚拟机栈的是：

Java虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，

而本地方法栈则为虚拟机使用到的Native方法服务。也会有 StackOverflowError 和 OutOfMemoryError 异常。

### 程序计数器

内存空间小，线程私有。字节码解释器 工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、跳转、异常处理、线程恢复等基础功能都需要依赖计数器来完成。

如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；

如果正在执行的是Native方法，这个计数器的值为 `Undefined`。

此内存区域是唯一一个在Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。

### 堆

对大多数应用来说，这块区域是JVM所管理的内存中最大的一块。

线程共享。主要存放对象实例和数组。

### 方法区

线程共享。存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据



现在用一张图来介绍每个区域存储的内容。

### ![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGE3N2Q5MDE0Njc4NmMwY2IzZTE3MGI5YzkzNzZhZTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

### 运行时常量池

属于方法区的一部分，用来存放编译期生成的各种字面量和符号引用。

编译期和运行期都可以将常量放入池中，内存有限，无法申请时抛出OutOfMemoryError。

### 直接内存

非虚拟机运行时数据区的部分

## 执行引擎

分配给运行时数据区的字节码将由执行引擎执行。执行引擎读取字节码并逐段执行。

> **① 解释器**: 解释器能快速的**解释字节码**，但执行却很慢。 解释器的缺点就是,当一个方法被调用多次，每次都需要重新解释。
> **② 编译器：**JIT编译器消除了解释器的缺点。执行引擎利用解释器转换字节码，但如果是重复的代码则使用**JIT编译器将全部字节码编译成本机代码**。

字节码文件只是JVM的一套指令集规范，不能直接交由底层操作系统去执行，因此需要特定的命令解析器（执行引擎），将字节码翻译成底层系统指令，再交由CPU执行，这个过程需要调用其他语言的本地库接口，来实现整个程序的功能。



## 垃圾回收器和内存分配策略

### 概述

程序计数器、虚拟机栈、本地方法栈这三个区域随线程生灭（因为是线程私有），

栈中的栈帧随着方法的进入和退出相应的执行着入栈和出栈操作。

而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期才知道哪些对象创建，这部分内存的分配和回收都是动态的，垃圾回收器所关注的就是这部分内存。

### 对象是否存活

在进行内存回收之前要做的事情就是，判断哪些对象是死的，哪些对象是活的。

#### 引用计数法

给对象添加一个引用计数器，但是难以解决循环引用的问题。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNGMyODlhMjI0Y2I0OTQ0ZTQ5OWZiNWJmZDMzZTU5MmY_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

从图中可以看出，直接将obj1-reference 和 obj2-reference 置为空，在Java堆中，两块内存依然保持着相互引用，而无法回收。

#### 可达性分析法

通过一系列的`GC Roots`  的对象作为起始点，从这些节点所走过的路径称为引用链。

当一个对象到 GC Roots 没有任何引用链相连的时候，说明对象不可用。

<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNThiZmFjMTVjYTZkMzA3NmRlZjUxNzRlZDVjYTVhOTk_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" style="zoom: 50%;" />

可作为GC Roots的对象：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（即一般说的 Native方法）引用的对象



GC Roots对象的类型比较常见的是静态变量以及栈中的引用。

静态变量比较好理解，他在整个进程的执行期间不会被回收，因此他肯定是有用的。

栈，这里指的是 JVM 运行数据区域中的方法栈，也就是局部变量引用，在方法执行期间肯定是活跃的。由于方法栈属于线程私有，因此这里等于活跃线程持有的对象不会被回收。

#### 生存还是死亡

即使在可达性分析算法中不可达的对象，也并非是非死不可的，这时候他们暂时处于‘缓刑’阶段，一个对象的真正死亡至少要经历两次标记过程：如果对象在进行可达性分析后没有发现与GC Roots 相连接的引用链，那他将会第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行finalize()方法。

- 当对象没有覆盖finalize() 方法，
- 此方法已经被虚拟机调用过

虚拟机将这两种情况都视为没有必要执行。

如果这个对象被判定为有必要执行finalize()方法，那么这个对象会被放置到一个叫做F-Queue的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer 线程去执行它。所谓的执行是指：虚拟机会发这个消息，并不承诺或等待他运行结束。

finalize() 方法是对象逃脱死亡的最后一次机会，稍后GC将对F-Queue 中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何一个对象建立关联即可。

finalize() 方法只会被系统自动调用一次。

#### 回收方法区

在堆中，尤其在新生代中，一次垃圾回收一般可以回收70%～95%的空间，而永久代的垃圾收集效率远低于此。

在永久代垃圾回收主要两部分内容：废弃的常量和无用的类。

判断废弃常量：一般是判断没有该常量的引用。

判断无用的类，要以下三个条件都满足

- 该类的所有实例都已经回收，也就是在Java堆中不存在该类的任何实例
- 加载该类的ClassLoader 已经被回收
- 该类对应的java.lang.Class 对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法

### 垃圾回收算法

#### 标记---清除算法

直接标记清除。

两个不足：

- 效率不高
- 空间会产生大量碎片

#### 复制算法

把空间分成两块，每次只对其中一块进行GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。

解决前一种方法的不足，但是会造成空间利用率低下。

因为大多数新生代对象都不会熬过第一次 GC。所以没必要 1 : 1 划分空间。可以分一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另一块 Survivor 上，最后清理 Eden 和 Survivor 空间。大小比例一般是 8 : 1 : 1，每次浪费 10% 的 Survivor 空间。但是这里有一个问题就是如果存活的大于 10% 怎么办？这里采用一种分配担保策略：多出来的对象直接进入老年代。


#### 标记---整理算法

不同于针对新生代的复制算法，针对老年代的特点，创建该算法。主要是把存活对象移到内存的一端。

#### 分代回收

根据存活对象划分为几块内存区，一般是分为新生代和老年代。然后根据各个年代的特点制定相应的回收算法。

##### 新生代

每次垃圾回收都有大量对象死去，只有少量存活，选择复制算法比较合理。

##### 老年代

老年代中对象存活率比较高，没有额外的空间分配对它进行担保，所以必须使用标记---清除或者标记--整理算法回收

### 内存分配与回收策略

对象优先在Eden分配

对象主要分配在新生代的Eden区上，少数情况会直接分配在老年代中

一般来说，Java堆中的内存模型如下图所示：

<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvOTcxMDE4MDMxNWQzNTc1NmI2OGU5YzVkYWY0NGQ2ZTU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" style="zoom:50%;" />

#### 新生代GC(Minor GC)

发生在新生代的垃圾回收动作，频繁，速度快

#### 老年代GC(Major GC/ Full GC)

对整个堆进行回收，包括新生代和老年代。由于Full GC需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数，导致Full GC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显式调用等。

- 大对象直接进入老年代
- 长期存活的对象将进入老年代

## Java内存模型

### 为什么有内存模型

Java内存模型（JMM   Java Memory Model）

#### CPU缓存一致性

计算机在执行程序的时候，每条指令都是在CPU中执行的，执行的时候需要和数据打交道（数据存放在计算机主内存中，也就是物理内存），随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入的过程和CPU的执行速度比起来差距越来越大，导致CPU每次操作内存都会耗费很多等待的时间。

人们想出来了一个办法，就是在CPU和内存之间增加高速缓存。就是保存一份数据拷贝，它的特点就是：速度快，内存小，并且昂贵。

那么程序的执行过程就变成了：

当程序在执行过程中，那么CPU进行计算时就可以将运算需要的数据从主存复制一份到CPU的高速缓存中，

直接从它的高速缓存读取数据和向其中写入数据，当运算结束，再将高速缓存中的数据刷新到主存中。

**在CPU和主存之间增加高速缓存，在多线程场景下就可能会存在缓存一致性的问题。**

也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。

#### 处理器优化和指令重排序

除了上面提到的，在CPU和主存之间添加高速缓存，在多线程场景下会存在缓存一致性的问题。

除了这种情况，还有一种硬件问题：

为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入的代码进行乱序进行处理，这就是**处理器优化**。

除了硬件，很多变成语言的编译器也有类似的优化，比如Java虚拟机的即时编译（JIT）也叫做**指令重排**。

如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。

### 并发编程的问题

并发编程，为了保证数据的安全，需要满足以下三个特性：

- 原子性

  指在一个操作中，CPU不得中途暂停然后在调度，即不被中断操作，要么执行完成，要么不执行。

- 可见性

  当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改的值。

  Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种

  依赖主内存作为传递媒介的方式来实现的。

  volatile关键字，被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次使用之前都从主内存刷新。

  因此，可以使用volatile来保证多线程操作时变量的可见性。

- 有序性

  即程序执行的顺序按照代码的先后顺序执行。

  在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。

  实现方式有所区别：

  - volatile关键字会禁止指令重排。

  - synchronized关键字保证同一时刻只允许一条线程操作。

### 内存屏障

内存屏障，也叫内存栅栏，是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。

LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。 在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。

### 内存模型

为了解决上面提到的缓存一致性、处理器优化和指令重排序的问题，也就是为了保证并发编程中可以可以满足原子性、可见性和有序性，有了一个概念：**内存模型**。他是一种规范

为了保证共享内存的正确性（原子性、可见性、有序性），内存模型定义了在共享内存系统中，多线程程序读写操作行为的规范。

### Java内存模型

Java程序需要运行Java虚拟机上面。

**Java内存模型：一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异，保证了Java程序在各平台下，对内存的访问都能保证效果一致的机制和规范。**

Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。

而JMM就作用于工作内存和主存之间数据同步过程。**他规定了如何做数据同步以及什么时候做数据同步。**

![11](http://www.hollischuang.com/wp-content/uploads/2018/06/11.png)



JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地数据不一致、编译器会对代码进行指令重排序、处理器会对代码进行乱序执行带来的问题。

目的：保证并发场景中的原子性、可见性、有序性。

### Java内存模型的实现

Java中提供了一系列和并发处理相关的关键字，比如 volatile、synchronized、final、concurrent 包等。其实这些都是Java内存模型封装了底层的实现后，提供给程序员使用的一些关键字。

